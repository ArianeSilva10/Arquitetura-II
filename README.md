# Arquitetura e Organização de Computadores II 
Bem-vindo à disciplina Arquitetura e Organização de Computadores II! Este curso aborda os princípios fundamentais de organização e funcionamento de computadores, com ênfase em arquiteturas modernas, programação em baixo nível e interação com hardware. É uma continuação de conceitos apresentados em Arquitetura e Organização de Computadores I.

## Objetivos da Disciplina
Entender os principais componentes e funcionamento interno de um computador.
Desenvolver habilidades práticas de programação em linguagem Assembly.
Aprender a manipular registradores, memórias e periféricos em arquiteturas reais.
Explorar sistemas embarcados e controladores utilizando processadores modernos.
Analisar técnicas de otimização e execução eficiente de programas.

## Conteúdo Programático
#### Arquitetura e Microarquitetura:

Revisão de componentes internos do computador (CPU, memória, barramentos).
Estudo de pipelines, paralelismo e execução fora de ordem.

#### Conjuntos de Instruções (ISAs):

Arquiteturas RISC vs CISC.
Estudo de instruções de baixo nível.
 
#### Programação em Assembly:

Estrutura de programas Assembly.
Manipulação de registradores, flags e instruções aritméticas.
Controle de fluxo: branches, loops e subrotinas.

#### Sistemas Embarcados:

Interação com periféricos e GPIOs.
Controle de dispositivos de entrada e saída.
Configuração de timers e interrupções.

#### Memórias:

Organização e hierarquia de memória.
Cache: funcionamento e impacto no desempenho.

#### Comunicação com o Hardware:

Mapas de memória e mapeamento de registradores.
Controle de dispositivos utilizando portas de E/S.
Desativação de watchdog timers e configuração de multiplexadores.

#### Performance e Otimizações:

Pipeline hazards.
Técnicas de otimização de software para hardware específico.
Ferramentas e Recursos

### Durante a disciplina, utilizaremos as seguintes ferramentas:

Linguagem Assembly: Programação em baixo nível para arquiteturas específicas.

Sistemas embarcados: Placas como a BeagleBone Black para desenvolvimento prático.

Debuggers e Emuladores: Análise de execução em sistemas reais e simulados.

Datasheets e Memory Maps: Utilizados para entender e configurar registradores.
Atividades Práticas
A disciplina é fortemente prática, focamos em desenvolver projetos como:

Controle de LEDs e botões utilizando GPIOs.

Configuração de interrupções e timers.

Implementação de algoritmos básicos em Assembly.

Desenvolvimento de sistemas embarcados simples, como jogos ou controladores.
